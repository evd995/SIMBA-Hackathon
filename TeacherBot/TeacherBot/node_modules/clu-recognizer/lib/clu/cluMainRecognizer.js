"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CluMainRecognizer = void 0;
/* eslint-disable  @typescript-eslint/no-non-null-assertion */
/* eslint-disable  @typescript-eslint/no-explicit-any */
const botbuilder_1 = require("botbuilder");
const cluConstants_1 = require("../cluConstants");
/**
 * A CLU based implementation.
 */
class CluMainRecognizer {
    /**
     * Initializes a new instance of the CluMainRecognizer class.
     * @param recognizerOptions The CLU recognizer version options.
     * @param httpClient The HttpClient for the CLU API calls.
     */
    constructor(recognizerOptions, httpClient) {
        var _a, _b;
        this.recognizerOptions = recognizerOptions;
        this.httpClient = httpClient;
        this.telemetryClient =
            (_a = recognizerOptions.telemetryClient) !== null && _a !== void 0 ? _a : new botbuilder_1.NullTelemetryClient();
        this.logPersonalInformation =
            (_b = recognizerOptions.logPersonalInformation) !== null && _b !== void 0 ? _b : false;
        const { endpoint, projectName } = recognizerOptions.application;
        this.cacheKey = endpoint + projectName;
    }
    recognize(utteranceOrContext, ...rest) {
        if (typeof utteranceOrContext === 'string') {
            return this.recognizeWithUtterance(utteranceOrContext, ...rest);
        }
        const params = utteranceOrContext instanceof botbuilder_1.TurnContext ? [null, ...rest] : rest;
        return this.recognizeWithContext(utteranceOrContext, ...params);
    }
    /**
     * Invoked prior to a CluResult being logged.
     * @param recognizerResult The CLU results for the call.
     * @param turnContext Context object containing information for a single turn of conversation with a user.
     * @param telemetryProperties Additional properties to be logged to telemetry with the CluResult event.
     * @param telemetryMetrics Additional metrics to be logged to telemetry with the CluResult event.
     */
    onRecognizerResult(recognizerResult, turnContext, telemetryProperties, telemetryMetrics) {
        this.telemetryClient.trackEvent({
            name: cluConstants_1.CluConstants.Telemetry.CluResult,
            properties: this.fillCluEventProperties(recognizerResult, turnContext, telemetryProperties),
            metrics: telemetryMetrics,
        });
    }
    /**
     * Fills the event properties for CluResult event for telemetry.
     * These properties are logged when the recognizer is called.
     * @param recognizerResult Last activity sent from user.
     * @param turnContext Context object containing information for a single turn of conversation with a user.
     * @param telemetryProperties Additional properties to be logged to telemetry with the CluResult event.
     * @returns A dictionary that is sent as "Properties" to BotTelemetryClient.trackEvent method for the BotMessageSend event.
     */
    fillCluEventProperties(recognizerResult, turnContext, telemetryProperties) {
        var _a, _b, _c, _d, _e, _f;
        // Get top two intents.
        const [firstIntent, secondIntent] = Object.entries(recognizerResult.intents)
            .map(([intent, { score = 0 }]) => ({ intent, score }))
            .sort((a, b) => b.score - a.score);
        // Add the intent score and conversation id properties.
        const properties = {
            [cluConstants_1.CluConstants.Telemetry.ProjectNameProperty]: this.recognizerOptions
                .application.projectName,
            [cluConstants_1.CluConstants.Telemetry.IntentProperty]: (_a = firstIntent === null || firstIntent === void 0 ? void 0 : firstIntent.intent) !== null && _a !== void 0 ? _a : '',
            [cluConstants_1.CluConstants.Telemetry
                .IntentScoreProperty]: firstIntent === null || firstIntent === void 0 ? void 0 : firstIntent.score.toLocaleString('en-US'),
            [cluConstants_1.CluConstants.Telemetry.Intent2Property]: (_b = secondIntent === null || secondIntent === void 0 ? void 0 : secondIntent.intent) !== null && _b !== void 0 ? _b : '',
            [cluConstants_1.CluConstants.Telemetry
                .IntentScore2Property]: secondIntent === null || secondIntent === void 0 ? void 0 : secondIntent.score.toLocaleString('en-US'),
            [cluConstants_1.CluConstants.Telemetry.FromIdProperty]: (_d = (_c = turnContext.activity) === null || _c === void 0 ? void 0 : _c.from) === null || _d === void 0 ? void 0 : _d.id,
        };
        if (!recognizerResult.entities) {
            properties[cluConstants_1.CluConstants.Telemetry.EntitiesProperty] =
                recognizerResult.entities;
        }
        // Use the LogPersonalInformation flag to toggle logging PII data, text is a common example.
        if (this.logPersonalInformation && !((_f = (_e = turnContext.activity) === null || _e === void 0 ? void 0 : _e.text) === null || _f === void 0 ? void 0 : _f.trim())) {
            properties[cluConstants_1.CluConstants.Telemetry.QuestionProperty] =
                turnContext.activity.text;
        }
        // Additional Properties can override "stock" properties.
        if (telemetryProperties != null) {
            return Object.assign({}, properties, telemetryProperties);
        }
        return properties;
    }
    /**
     * Returns a RecognizerResult object.
     * @param utterance The utterance to recognize.
     * @param predictionOptions CluRecognizerOptions implementation to override current properties.
     * @returns RecognizerResult object.
     */
    recognizeWithUtterance(utterance, predictionOptions) {
        const recognizer = predictionOptions !== null && predictionOptions !== void 0 ? predictionOptions : this.recognizerOptions;
        return recognizer.recognize(utterance, this.httpClient);
    }
    /**
     * Returns a RecognizerResult object.
     * @param context The current dialog context or turn context.
     * @param activity The activity to recognize.
     * @param predictionOptions CluRecognizerOptions implementation to override current properties.
     * @param telemetryProperties Additional properties to be logged to telemetry with the CluResult event.
     * @param telemetryMetrics Additional metrics to be logged to telemetry with the CluResult event.
     * @returns RecognizerResult object.
     */
    recognizeWithContext(context, activity, predictionOptions, telemetryProperties, telemetryMetrics) {
        return __awaiter(this, void 0, void 0, function* () {
            const turnContext = context instanceof botbuilder_1.TurnContext ? context : context.context;
            const recognizer = predictionOptions !== null && predictionOptions !== void 0 ? predictionOptions : this.recognizerOptions;
            const cached = turnContext.turnState.get(this.cacheKey);
            if (cached) {
                this.telemetryClient.trackEvent({
                    name: cluConstants_1.CluConstants.TrackEventOptions.ReadFromCachedResultEventName,
                    metrics: telemetryMetrics,
                    properties: telemetryProperties,
                });
                return cached;
            }
            const result = context instanceof botbuilder_1.TurnContext
                ? yield recognizer.recognize(turnContext, this.httpClient)
                : yield recognizer.recognize(context, activity, this.httpClient);
            this.onRecognizerResult(result, turnContext, telemetryProperties, telemetryMetrics);
            turnContext.turnState.set(this.cacheKey, result);
            this.telemetryClient.trackEvent({
                name: cluConstants_1.CluConstants.TrackEventOptions.ResultCachedEventName,
                metrics: telemetryMetrics,
                properties: telemetryProperties,
            });
            return result;
        });
    }
}
exports.CluMainRecognizer = CluMainRecognizer;
//# sourceMappingURL=cluMainRecognizer.js.map